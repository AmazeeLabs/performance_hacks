<?php
// $Id$

/**
 * @file
 * Performance hacks which are too hacky to hack into core.
 */

/**
 * Implements hook_menu_alter().
 */
function performance_hacks_menu_alter(&$items) {
  // Use a custom callback for node/% to bypass node_tag_new().
  $items['node/%node']['page callback'] = 'performance_hacks_node_show';

  // Replace _node_revision_access() with a callback that doesn't do a COUNT()
  // query on the node table. Will show revisions tab to all users with access
  // even if there's only one revision.
  // @see http://drupal.org/node/808739
  $items['node/%node/revisions']['access callback'] = '_performance_hacks_node_revision_access';
}

/**
 * Implements hook_module_implements_alter().
 */
function performance_hacks_module_implements_alter(&$implementations, $hook) {
  // node_field_display_module_alter() disables all labels on all fields
  // when the view mode is 'search_index'. If you set display modes for
  // this view mode by hand, then the hook isn't needed. Since this
  // may be called hundreds of times on some pages, it's worth disabling it.
  // @see http://drupal.org/node/834278
  if ($hook == 'field_display_node_alter') {
    unset($implementations['node']);
  }
}

/**
 * Implements hook_node_update().
 */
function performance_hacks_node_update($node) {
  // When a node is updated, clear cache for all rendered versions.
  cache_clear_all("node:render:$node->nid", 'cache_block', TRUE);
}

/**
 * Implements hook_node_delete().
 */
function performance_hacks_node_delete($node) {
  // Clean up cache entries for this node.
  cache_clear_all("node:render:$node->nid", 'cache_block', TRUE);
}

/**
 * Implements hook_comment_insert().
 */
function performance_hacks_comment_insert($comment) {
  // Clear the render cache for nodes when comments are added.
  // Only clear full view since this is where comments are usually
  // displayed.
  cache_clear_all("node:render:$comment->nid:full", 'cache_block', TRUE);
}

/**
 * Implements hook_comment_update().
 */
function performance_hacks_comment_update($comment) {
  cache_clear_all("node:render:$comment->nid:full", 'cache_block', TRUE);
}

/**
 * Implements hook_comment_delete().
 */
function performance_hacks_comment_delete($comment) {
  cache_clear_all("node:render:$comment->nid:full", 'cache_block', TRUE);
}

/**
 * Page callback to display a node.
 *
 * node_tag_new() causes an SQL merge query on every page. This will cause
 * new/updated marks not to work.
 *
 * @see node_show()
 */
function performance_hacks_node_show($node, $message = FALSE) {
  if ($message) {
    drupal_set_title(t('Revision of %title from %date', array('%title' => $node->title, '%date' => format_date($node->revision_timestamp))), PASS_THROUGH);
  }

  // For markup consistency with other pages, use node_view_multiple() rather
  // than node_view().
  return node_view_multiple(array($node->nid => $node), 'full');
}

/**
 * Construct a drupal_render() style array from an array of loaded nodes.
 *
 * Direct replacement for node_view_multiple which render caches node teasers.
 *
 * @see @node_view_multiple().
 */
function performance_hacks_node_view_multiple($nodes, $view_mode = 'teaser', $weight = 0) {
  // No changes from node_view_multiple except for swapping out node_view()
  // with our own version. The idea behind render caching each node teaser
  // individually is to avoid having to clear the cache when new content is
  // posted, instead we can clear it only when nodes are updated (just about).
  field_attach_prepare_view('node', $nodes, $view_mode);
  entity_prepare_view('node', $nodes);
  $build = array();
  foreach ($nodes as $node) {
    $build['nodes'][$node->nid] = performance_hacks_replace_node_view($node, $view_mode);
    $build['nodes'][$node->nid]['#weight'] = $weight;
    $weight++;
  }
  $build['nodes']['#sorted'] = TRUE;
  return $build;
}

/**
 * Generate an array for rendering the given node.
 *
 * Replacement for node_view() which does drupal_render() caching.
 */
function  performance_hacks_replace_node_view($node, $view_mode = 'full') {
  // For now, cache by nid, current user uid, and view mode.
  // @todo: add language and consider making this alterable.
  $cid = 'node:render:' . $node->nid . ':' . $view_mode . ':' . $GLOBALS['user']->uid;

  // Cache for a maximum of three days, updates to users, taxonomy terms,
  // theming, or other things which affect the rendered node output without
  // updating the node object directly will not trigger a cache flush. So a
  // three day expiry allows these changes to propagate to node listings
  // gradually.
  $expire = 84000 * 3;

  $build = array(
    '#theme' => 'node',
    '#node' => $node,
    '#view_mode' => $view_mode,
    '#pre_render' => array('_performance_hacks_node_build_content'),
    '#cache' => array(
       'cid' => $cid,
       'bin' => 'cache_block',
       'expire' => REQUEST_TIME + $expire,
    ),
  );
  // Add contextual links for this node, except when the node is already being
  // displayed on its own page. Modules may alter this behavior (for example,
  // to restrict contextual links to certain view modes) by implementing
  // hook_node_view_alter().
  if (!node_is_page($node)) {
    $build['#contextual_links']['node'] = array('node', array($node->nid));
  }

  return $build;
}

/**
 * Replacement for node_build_content() for pre_render().
 */
function _performance_hacks_node_build_content($element) {
  // To avoid rewriting the whole function, assign $node and
  // $view_mode, the $node will be passed by resource so no need
  // to stuff it back at the end. 
  $node = $element['#node'];
  $view_mode = $element['#view_mode'];
  // Remove previously built content, if exists.
  $node->content = array();

  // The 'view' hook can be implemented to overwrite the default function
  // to display nodes.
  if (node_hook($node, 'view')) {
    $node = node_invoke($node, 'view', $view_mode);
  }

  // Build fields content.
  // In case of a multiple view, node_view_multiple() already ran the
  // 'prepare_view' step. An internal flag prevents the operation from running
  // twice.
  field_attach_prepare_view('node', array($node->nid => $node), $view_mode);
  entity_prepare_view('node', array($node->nid => $node));
  $node->content += field_attach_view('node', $node, $view_mode);

  // Always display a read more link on teasers because we have no way
  // to know when a teaser view is different than a full view.
  $links = array();
  if ($view_mode == 'teaser') {
    $links['node-readmore'] = array(
      'title' => t('Read more'),
      'href' => 'node/' . $node->nid,
      'attributes' => array('rel' => 'tag', 'title' => strip_tags($node->title))
    );
  }
  $node->content['links']['node'] = array(
    '#theme' => 'links__node',
    '#links' => $links,
    '#attributes' => array('class' => array('links', 'inline')),
  );

  // Allow modules to make their own additions to the node.
  module_invoke_all('node_view', $node, $view_mode);

  $element += $node->content;
  unset($node->content);

  // Run hook_node_view_alter() here instead of in node_view() because this
  // is the last time you're going to see a renderable array again. mwahaha.
  drupal_alter('node_view', $element);

  return $element;
}

/**
 * Copy of _node_revision_access() which skips doing a COUNT().
 */
function _performance_hacks_node_revision_access($node, $op = 'view') {
  $access = &drupal_static(__FUNCTION__, array());
  if (!isset($access[$node->vid])) {
    // To save additional calls to the database, return early if the user
    // doesn't have the required permissions.
    $map = array('view' => 'view revisions', 'update' => 'revert revisions', 'delete' => 'delete revisions');
    if (isset($map[$op]) && (!user_access($map[$op]) && !user_access('administer nodes'))) {
      $access[$node->vid] = FALSE;
      return FALSE;
    }

    $node_current_revision = node_load($node->nid);
    $is_current_revision = $node_current_revision->vid == $node->vid;

    // There should be at least two revisions. If the vid of the given node
    // and the vid of the current revision differs, then we already have two
    // different revisions so there is no need for a separate database check.
    // Also, if you try to revert to or delete the current revision, that's
    // not good.
    if ($is_current_revision && ($op == 'update' || $op == 'delete')) {
      $access[$node->vid] = FALSE;
    }
    elseif (user_access('administer nodes')) {
      $access[$node->vid] = TRUE;
    }
    else {
      // First check the access to the current revision and finally, if the
      // node passed in is not the current revision then access to that, too.
      $access[$node->vid] = node_access($op, $node_current_revision) && ($is_current_revision || node_access($op, $node));
    }
  }
  return $access[$node->vid];
}
