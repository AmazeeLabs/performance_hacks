<?php
// $Id$

/**
 * @file
 * Performance hacks which are too hacky to hack into core.
 */

/**
 * Implements hook_menu_alter().
 */
function performance_hacks_menu_alter(&$items) {
  // Use a custom callback for node/% to bypass node_tag_new().
  $items['node/%node']['page callback'] = 'performance_hacks_node_show';

  // Replace _node_revision_access() with a callback that doesn't do a COUNT()
  // query on the node table. Will show revisions tab to all users with access
  // even if there's only one revision.
  // @see http://drupal.org/node/808739
  $items['node/%node/revisions']['access callback'] = '_performance_hacks_node_revision_access';
}

/**
 * Implements hook_module_implements_alter().
 */
function performance_hacks_module_implements_alter(&$implementations, $hook) {
  // node_field_display_module_alter() disables all labels on all fields
  // when the view mode is 'search_index'. If you set display modes for
  // this view mode by hand, then the hook isn't needed. Since this
  // may be called hundreds of times on some pages, it's worth disabling it.
  // @see http://drupal.org/node/834278
  if ($hook == 'field_display_node_alter') {
    unset($implementations['node']);
  }
}

/**
 * Implements hook_node_update().
 */
function performance_hacks_node_update($node) {
  // When a node is updated, clear cache for all rendered versions.
  cache_clear_all("node:render:$node->nid", 'cache_block', TRUE);
}

/**
 * Implements hook_node_delete().
 */
function performance_hacks_node_delete($node) {
  // Clean up cache entries for this node.
  cache_clear_all("node:render:$node->nid", 'cache_block', TRUE);
}

/**
 * Implements hook_comment_insert().
 */
function performance_hacks_comment_insert($comment) {
  // Clear the render cache for nodes when comments are added.
  // Only clear full view since this is where comments are usually
  // displayed.
  cache_clear_all("node:render:$comment->nid:full", 'cache_block', TRUE);
}

/**
 * Implements hook_comment_update().
 */
function performance_hacks_comment_update($comment) {
  cache_clear_all("node:render:$comment->nid:full", 'cache_block', TRUE);
}

/**
 * Implements hook_comment_delete().
 */
function performance_hacks_comment_delete($comment) {
  cache_clear_all("node:render:$comment->nid:full", 'cache_block', TRUE);
}

/**
 * Page callback to display a node.
 *
 * node_tag_new() causes an SQL merge query on every page. This will cause
 * new/updated marks not to work.
 *
 * @see node_show()
 */
function performance_hacks_node_show($node, $message = FALSE) {
  if ($message) {
    drupal_set_title(t('Revision of %title from %date', array('%title' => $node->title, '%date' => format_date($node->revision_timestamp))), PASS_THROUGH);
  }

  // For markup consistency with other pages, use node_view_multiple() rather
  // than node_view().
  return performance_hacks_node_view_multiple(array($node->nid => $node), 'full');
}

/**
 * Construct a drupal_render() style array from an array of loaded nodes.
 *
 * Direct replacement for node_view_multiple which render caches node teasers.
 *
 * @see @node_view_multiple().
 */
function performance_hacks_node_view_multiple($nodes, $view_mode = 'teaser', $weight = 0) {

  // If there's a cache miss, we want the prepare view stage to run
  // in 'multiple' mode. If all nodes are a cache hit, it doesn't need to
  // run at all. To get around this, check if we have a full cache hit before
  // running the two functions.
  // @todo: consider trying to keep a static of cache hits so we don't have
  // to run cache_get_multiple() and cache_get() separately. This requires
  // custom caching instead of drupal_render().
  $cids = array();
  foreach ($nodes as $node) {
    $cids[] = 'node:render:' . $node->nid . ':' . $view_mode . ':' . $GLOBALS['user']->uid;
  }
  $cached = cache_get_multiple($cids, 'cache_block');
  if (count($cached) != count($nodes)) {
    field_attach_prepare_view('node', $nodes, $view_mode);
    entity_prepare_view('node', $nodes);
  }
  $build = array();
  foreach ($nodes as $node) {
    $build['nodes'][$node->nid] = performance_hacks_replace_node_view($node, $view_mode);
    $build['nodes'][$node->nid]['#weight'] = $weight;
    $weight++;
  }
  $build['nodes']['#sorted'] = TRUE;
  return $build;
}

/**
 * Generate an array for rendering the given node.
 *
 * Replacement for node_view() which does drupal_render() caching.
 */
function  performance_hacks_replace_node_view($node, $view_mode = 'full') {
  // For now, cache by nid, current user uid, and view mode.
  // @todo: add language.
  $custom = variable_get('performance_hacks_custom_cache_key', '');

  $cid = 'node:render:' . $node->nid . ':' . $view_mode . ':' . $GLOBALS['user']->uid . ':' $custom;

  // Cache for a maximum of three days, updates to users, taxonomy terms,
  // theming, or other things which affect the rendered node output without
  // updating the node object directly will not trigger a cache flush. So a
  // three day expiry allows these changes to propagate to node listings
  // gradually. Custom settings per view mode can be put in $conf.
  $expire = variable_get('node_cache_' . $view_mode . '_expire', 86400 * 3);

  $build = array(
    '#theme' => 'node',
    '#node' => $node,
    '#view_mode' => $view_mode,
    '#pre_render' => array('_performance_hacks_node_build_content'),
    '#cache' => array(
       'cid' => $cid,
       'bin' => 'cache_block',
       'expire' => REQUEST_TIME + $expire,
    ),
  );
  // Add contextual links for this node, except when the node is already being
  // displayed on its own page. Modules may alter this behavior (for example,
  // to restrict contextual links to certain view modes) by implementing
  // hook_node_view_alter().
  if (!node_is_page($node)) {
    $build['#contextual_links']['node'] = array('node', array($node->nid));
  }

  return $build;
}

/**
 * Replacement for node_build_content() for pre_render().
 */
function _performance_hacks_node_build_content($element) {
  // To avoid rewriting the whole function, assign $node and
  // $view_mode, the $node will be passed by resource so no need
  // to stuff it back at the end. 
  $node = $element['#node'];
  $view_mode = $element['#view_mode'];
  // Remove previously built content, if exists.
  $node->content = array();

  // The 'view' hook can be implemented to overwrite the default function
  // to display nodes.
  if (node_hook($node, 'view')) {
    $node = node_invoke($node, 'view', $view_mode);
  }

  // Build fields content.
  // In case of a multiple view, node_view_multiple() already ran the
  // 'prepare_view' step. An internal flag prevents the operation from running
  // twice.
  field_attach_prepare_view('node', array($node->nid => $node), $view_mode);
  entity_prepare_view('node', array($node->nid => $node));
  $node->content += field_attach_view('node', $node, $view_mode);

  // Always display a read more link on teasers because we have no way
  // to know when a teaser view is different than a full view.
  $links = array();
  if ($view_mode == 'teaser') {
    $links['node-readmore'] = array(
      'title' => t('Read more'),
      'href' => 'node/' . $node->nid,
      'attributes' => array('rel' => 'tag', 'title' => strip_tags($node->title))
    );
  }
  $node->content['links']['node'] = array(
    '#theme' => 'links__node',
    '#links' => $links,
    '#attributes' => array('class' => array('links', 'inline')),
  );

  // Allow modules to make their own additions to the node.
  module_invoke_all('node_view', $node, $view_mode);

  $element += $node->content;
  unset($node->content);

  // Run hook_node_view_alter() here instead of in node_view() because this
  // is the last time you're going to see a renderable array again. mwahaha.
  drupal_alter('node_view', $element);

  return $element;
}

/**
 * Replace node_feed() to incorporate render caching.
 */
function performance_hacks_replace_node_feed($nids = FALSE, $channel = array()) {
  global $base_url, $language;

  // Allow page caching of RSS feeds to be set differently from  regular pages.
  if (variable_get('performance_hacks_rss_cache_lifetime', NULL) !== NULL) {
    $GLOBALS['conf']['cache_)ifetime'] = variable_get('performance_hacks_rss_cache_lifetime');
  }

  if ($nids === FALSE) {
    $nids = db_select('node', 'n')
      ->fields('n', array('nid', 'created'))
      ->condition('n.promote', 1)
      ->condition('status', 1)
      ->orderBy('n.created', 'DESC')
      ->range(0, variable_get('feed_default_items', 10))
      ->addTag('node_access')
      ->execute()
      ->fetchCol();
  }

  $item_length = variable_get('feed_item_length', 'fulltext');
  $namespaces = array('xmlns:dc' => 'http://purl.org/dc/elements/1.1/');
  $teaser = ($item_length == 'teaser');

  // Load all nodes to be rendered.
  $nodes = node_load_multiple($nids);
  $items = '';
  foreach ($nodes as $node) {
    $item_text = '';

    $node->link = url("node/$node->nid", array('absolute' => TRUE));
    $node->rss_namespaces = array();
    $node->rss_elements = array(
      array('key' => 'pubDate', 'value' => gmdate('r', $node->created)),
      array('key' => 'dc:creator', 'value' => $node->name),
      array('key' => 'guid', 'value' => $node->nid . ' at ' . $base_url, 'attributes' => array('isPermaLink' => 'false'))
    );

    // The node gets built and modules add to or modify $node->rss_elements
    // and $node->rss_namespaces.
    // Only change from core node_feed().
    $build = performance_hacks_replace_node_view($node, 'rss');
    unset($build['#theme']);

    if (!empty($node->rss_namespaces)) {
      $namespaces = array_merge($namespaces, $node->rss_namespaces);
    }

    if ($item_length != 'title') {
      // We render node contents and force links to be last.
      $build['links']['#weight'] = 1000;
      $item_text .= drupal_render($build);
    }

    $items .= format_rss_item($node->title, $node->link, $item_text, $node->rss_elements);
  }

  $channel_defaults = array(
    'version'     => '2.0',
    'title'       => variable_get('site_name', 'Drupal'),
    'link'        => $base_url,
    'description' => variable_get('feed_description', ''),
    'language'    => $language->language
  );
  $channel_extras = array_diff_key($channel, $channel_defaults);
  $channel = array_merge($channel_defaults, $channel);

  $output = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n";
  $output .= "<rss version=\"" . $channel["version"] . "\" xml:base=\"" . $base_url . "\" " . drupal_attributes($namespaces) . ">\n";
  $output .= format_rss_channel($channel['title'], $channel['link'], $channel['description'], $items, $channel['language'], $channel_extras);
  $output .= "</rss>\n";

  drupal_add_http_header('Content-Type', 'application/rss+xml; charset=utf-8');
  print $output;
}

/**
 * Copy of _node_revision_access() which skips doing a COUNT().
 */
function _performance_hacks_node_revision_access($node, $op = 'view') {
  $access = &drupal_static(__FUNCTION__, array());
  if (!isset($access[$node->vid])) {
    // To save additional calls to the database, return early if the user
    // doesn't have the required permissions.
    $map = array('view' => 'view revisions', 'update' => 'revert revisions', 'delete' => 'delete revisions');
    if (isset($map[$op]) && (!user_access($map[$op]) && !user_access('administer nodes'))) {
      $access[$node->vid] = FALSE;
      return FALSE;
    }

    $node_current_revision = node_load($node->nid);
    $is_current_revision = $node_current_revision->vid == $node->vid;

    // There should be at least two revisions. If the vid of the given node
    // and the vid of the current revision differs, then we already have two
    // different revisions so there is no need for a separate database check.
    // Also, if you try to revert to or delete the current revision, that's
    // not good.
    if ($is_current_revision && ($op == 'update' || $op == 'delete')) {
      $access[$node->vid] = FALSE;
    }
    elseif (user_access('administer nodes')) {
      $access[$node->vid] = TRUE;
    }
    else {
      // First check the access to the current revision and finally, if the
      // node passed in is not the current revision then access to that, too.
      $access[$node->vid] = node_access($op, $node_current_revision) && ($is_current_revision || node_access($op, $node));
    }
  }
  return $access[$node->vid];
}

/**
 * Replace menu_secondary_menu().
 */
function performance_hacks_replace_menu_secondary_menu() {
  // If the secondary menu source is set as the primary menu, we display the
  // second level of the primary menu.
  if (variable_get('menu_secondary_links_source', 'user-menu') == variable_get('menu_main_links_source', 'main-menu')) {
    return performance_hacks_replace_menu_navigation_links(variable_get('menu_main_links_source', 'main-menu'), 1);
  }
  else {
    return performance_hacks_replace_menu_navigation_links(variable_get('menu_secondary_links_source', 'user-menu'), 0);
  }
}

/**
 * Replace menu_navigation_links().
 *
 * This should only be used for primary links variable with simply menus.
 */
function performance_hacks_replace_menu_navigation_links($menu_name, $level = 0) {
  // Don't even bother querying the menu table if no menu is specified.
  if (empty($menu_name)) {
    return array();
  }

  // Get the menu hierarchy for the current page.
  $tree = performance_hacks_replace_menu_tree_page_data($menu_name, $level + 1);

  // Go down the active trail until the right level is reached.
  while ($level-- > 0 && $tree) {
    // Loop through the current level's items until we find one that is in trail.
    while ($item = array_shift($tree)) {
      if ($item['link']['in_active_trail']) {
        // If the item is in the active trail, we continue in the subtree.
        $tree = empty($item['below']) ? array() : $item['below'];
        break;
      }
    }
  }

  // Create a single level of links.
  $links = array();
  foreach ($tree as $item) {
    if (!$item['link']['hidden']) {
      $class = '';
      $l = $item['link']['localized_options'];
      $l['href'] = $item['link']['href'];
      $l['title'] = $item['link']['title'];
      if ($item['link']['in_active_trail']) {
        $class = ' active-trail';
      }
      // Keyed with the unique mlid to generate classes in theme_links().
      $links['menu-' . $item['link']['mlid'] . $class] = $l;
    }
  }
  return $links;
}
/**
 * Replacement for menu_tree_page_data().
 *
 * This version of menu_tree_page_data() changes the per-page cache to a
 * global cache, and doesn't bother trying to find parents or children
 * for the current menu item. This saves 3 queries per page with a cold
 * menu cache.
 */
function performance_hacks_replace_menu_tree_page_data($menu_name, $max_depth = NULL) {
  $tree = &drupal_static(__FUNCTION__, array());

  // Load the menu item corresponding to the current page.
  if ($item = menu_get_item()) {
    if (isset($max_depth)) {
      $max_depth = min($max_depth, MENU_MAX_DEPTH);
    }
    // Generate a cache ID (cid) specific for this page.
    $cid = 'links:' . $menu_name . ':page-cid:' . ':' . $GLOBALS['language']->language . ':' . (int) $item['access'] . ':' . (int) $max_depth;

    if (!isset($tree[$cid])) {
      $tree_parameters = array(
        'min_depth' => 1,
        'max_depth' => $max_depth,
      );
      // Build the tree using the parameters; the resulting tree will be cached
      // by _menu_build_tree().
      $tree[$cid] = ex_menu_build_tree($menu_name, $tree_parameters);
    }
    return $tree[$cid];
  }

  return array();
}

/**
 * @todo REMOVE AFTER CORE MERGE.
 */
function _ex_menu_build_tree($menu_name, array $parameters = array()) {
  // Static cache of already built menu trees.
  $trees = &drupal_static(__FUNCTION__, array());

  // Build the cache id; sort parents to prevent duplicate storage and remove
  // default parameter values.
  if (isset($parameters['expanded'])) {
    sort($parameters['expanded']);
  }
  $tree_cid = 'links:' . $menu_name . ':tree-data:' . $GLOBALS['language']->language . ':' . hash('sha256', serialize($parameters));

  // If we do not have this tree in the static cache, check {cache_menu}.
  if (!isset($trees[$tree_cid])) {
    $cache = cache_get($tree_cid, 'cache_menu');
    if ($cache && isset($cache->data)) {
      $trees[$tree_cid] = $cache->data;
    }
  }

  if (!isset($trees[$tree_cid])) {
    // Select the links from the table, and recursively build the tree. We
    // LEFT JOIN since there is no match in {menu_router} for an external
    // link.
    $query = db_select('menu_links', 'ml', array('fetch' => PDO::FETCH_ASSOC));
    $query->addTag('translatable');
    $query->leftJoin('menu_router', 'm', 'm.path = ml.router_path');
    $query->fields('ml');
    $query->fields('m', array(
      'load_functions',
      'to_arg_functions',
      'access_callback',
      'access_arguments',
      'page_callback',
      'page_arguments',
      'delivery_callback',
      'title',
      'title_callback',
      'title_arguments',
      'theme_callback',
      'theme_arguments',
      'type',
      'description',
    ));
    for ($i = 1; $i <= MENU_MAX_DEPTH; $i++) {
      $query->orderBy('p' . $i, 'ASC');
    }
    $query->condition('ml.menu_name', $menu_name);
    if (!empty($parameters['expanded'])) {
      $query->condition('ml.plid', $parameters['expanded'], 'IN');
    }
    $min_depth = (isset($parameters['min_depth']) ? $parameters['min_depth'] : 1);
    if ($min_depth != 1) {
      $query->condition('ml.depth', $min_depth, '>=');
    }
    if (isset($parameters['max_depth'])) {
      $query->condition('ml.depth', $parameters['max_depth'], '<=');
    }

    // Build an ordered array of links using the query result object.
    $links = array();
    foreach ($query->execute() as $item) {
      $links[] = $item;
    }
    $active_link = (isset($parameters['active_trail']) ? $parameters['active_trail'] : array());
    $data['tree'] = menu_tree_data($links, $active_link, $min_depth);
    $data['node_links'] = array();
    menu_tree_collect_node_links($data['tree'], $data['node_links']);

    // Cache the data, if it is not already in the cache.
    cache_set($tree_cid, $data, 'cache_menu');
    $trees[$tree_cid] = $data;
  }

  return $trees[$tree_cid];
}

function ex_menu_build_tree($menu_name, array $parameters = array()) {
  // Build the menu tree.
  $data = _ex_menu_build_tree($menu_name, $parameters);
  // Check access for the current user to each item in the tree.
  menu_tree_check_access($data['tree'], $data['node_links']);
  return $data['tree'];
}
